#!/usr/bin/env node

'use strict';

const pkg = require('../package.json');
const util = require('util');
const readFile = util.promisify(require('fs').readFile);
const program = require('commander');
const sim = require('../src/');
const inquirer = require('inquirer');
const glob = util.promisify(require('glob'));

program
  .version(pkg.version)
  .option('-i, --inputspec [path]', '/path/to/inputSpec, defaults to ./test/inputspec.json, will interactively create one if none found')
  .option('-s, --compspec [path]', '/path/to/compSpec optional, defaults to cwd')
  .option('-c, --clientNumber <number>', 'number of clients ex: 4')
  .option('-d, --directory [path]', ' path to where input, output, and cache is stored. Defaults to ./test/[input|cache|output]');

program.on('--help', () => {
  console.log([ // eslint-disable-line
    '\tTest a computation in a COINSTAC simulated environment.\n\n',
    '\tPlease provide a pipeline specification specifying how to run your simulation.',
    '\tFor examples on how to define a specification, see:\n',
    `\t${pkg.homepage}/tree/master/test/pipeline-specs.\n\n`,
    '\tExample:\n\n',
    '\t  coinstac-sim -i inputSpec.json -c 2 -d ~/myUsername/foo',
  ].join(' '));
});

program.parse(process.argv);

readFile(program.compspec ? program.compspec : 'compspec.json')
.then(compSpec => Promise.all([compSpec, readFile(program.inputspec ? program.inputspec : 'inputspec.json')]))
.catch(err => {
  debugger;
})
.then((compSpec) => {
  const comp = JSON.parse(compSpec);
  const createInputSpec = (variable, key) => {
    return inquirer.prompt({
      type: 'input',
      name: 'Create an input spec',
      message: `Please give a ${variable.type} input for variable: ${key}
      Files can use glob paterns to resolve to multiple file paths from the input dir
      ie: **/*.txt`,
    }).then((value) => {
      Promise.all([
        variable.type === 'files' ? glob(value) : value,
      ]).then((resolvedVal) => {
        return {
          [key]: { value: resolvedVal[0] },
        };
      });
    });
  };

  let specProm;
  if (!program.inputspec) {
    specProm = Object.keys(comp.computation.input).reduce((prom, variable) => {
      debugger;
      return createInputSpec(comp.computation.input[variable], variable);
    }, Promise.resolve());
  }

  return Promise.all([specProm])
  .then(() => {
    debugger;
  });
});


sim.startRun(program)
.then(() => {
  // deal with results
});
