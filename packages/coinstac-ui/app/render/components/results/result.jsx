import React, { Component } from 'react';
import { connect } from 'react-redux';
import PropTypes from 'prop-types';
import { Button, Glyphicon, Tabs, Tab, Well } from 'react-bootstrap';
import TimeStamp from 'react-timestamp';
import BrowserHistory from 'react-router/lib/browserHistory';
import Box from './displays/box-plot';
import Scatter from './displays/scatter-plot';
import Table from './displays/result-table';
import Images from './displays/images';
import { getLocalRun } from '../../state/ducks/runs';

class Result extends Component {
  constructor(props) {
    super(props);

    this.state = {
      run: {},
      computationOutput: {},
      displayTypes: [],
      plotData: [],
    };
  }

  componentDidMount() {
    this.props.getLocalRun(this.props.params.resultId)
      .then((run) => {
        let plotData = {};

        // Checking display type of computation
        const stepsLength = run.pipelineSnapshot.steps.length;
        let displayTypes = run.pipelineSnapshot.steps[stepsLength - 1]
          .computations[0].computation.display;

        this.setState({
          computationOutput: run.pipelineSnapshot.steps[stepsLength - 1]
            .computations[0].computation.output,
          displayTypes,
        });

        if (displayTypes && !displayTypes.length) {
          const array = [];
          array[0] = displayTypes;
          displayTypes = array;
        }

        if (displayTypes && displayTypes.findIndex(disp => disp.type === 'scatter_plot') > -1) {
          plotData.testData = [];
          run.results.plots.map(result => (
            result.coordinates.map(val => (
              plotData.testData.push({
                name: result.title,
                x: val.x,
                y: val.y,
              })
            )
          )));
        } else if (displayTypes && displayTypes.findIndex(disp => disp.type === 'box_plot') > -1) {
          plotData.testData = [];
          run.results.x.map(val => (
            plotData.testData.push(val)
          ));
        } else {
          plotData = run.results;
        }

        this.setState({
          run,
          plotData,
          dummyData: [14, 15, 16, 16, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 19,
            19, 19, 20, 20, 20, 20, 20, 20, 21, 21, 22, 23, 24, 24, 29],
        });
      });
  }

  render() {
    const { run, plotData, computationOutput } = this.state;
    const { consortia } = this.props;
    const consortium = consortia.find(c => c.id === run.consortiumId);
    let displayTypes = this.state.displayTypes;
    let stepsLength = -1;
    let covariates = [];
    if (run && run.pipelineSnapshot) {
      stepsLength = run.pipelineSnapshot.steps.length;
    }

    if (stepsLength > 0 && run.pipelineSnapshot.steps[stepsLength - 1].inputMap
      && run.pipelineSnapshot.steps[stepsLength - 1].inputMap.covariates) {
      covariates = run.pipelineSnapshot.steps[stepsLength - 1]
        .inputMap.covariates.ownerMappings.map(m => m.name);
    }

    if (displayTypes && !displayTypes.length) {
      const array = [];
      array[0] = displayTypes;
      displayTypes = array;
    }

    return (
      <div>
        <Button className="custom" onClick={BrowserHistory.goBack}>
          <Glyphicon glyph="glyphicon glyphicon-arrow-left" />
        </Button>

        <Well bsSize="small" style={{ marginTop: 10 }}>
          <h2 style={{ marginTop: 0 }}>
            {consortium && run.pipelineSnapshot && (
              <span>{`Results: ${consortium.name} || ${run.pipelineSnapshot.name}`}</span>
            )}
          </h2>
          {
            run.startDate && (
              <div>
                <span className="bold">Start date: </span>
                <TimeStamp
                  time={run.startDate / 1000}
                  precision={2}
                  autoUpdate={10}
                  format="full"
                />
              </div>
            )
          }
          {
            run.endDate && (
              <div>
                <span className="bold">End date: </span>
                <TimeStamp
                  time={run.endDate / 1000}
                  precision={2}
                  autoUpdate={10}
                  format="full"
                />
              </div>
            )
          }
          {
            stepsLength > -1 && covariates.length > 0 && (
              <div>
                <span className="bold">Covariates: </span>
                {covariates.join(', ')}
              </div>
            )
          }
        </Well>

        <Tabs defaultActiveKey={0} id="uncontrolled-tab-example">
          {
            run && run.results && displayTypes
            && displayTypes.map((disp, index) => {
              const title = disp.type.replace('_', ' ')
                .replace(/\w\S*/g, txt => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase());
              return (
                <Tab
                  key={disp.type}
                  eventKey={index}
                  title={`${title} View`}
                  style={{ padding: 10 }}
                >
                  {
                    disp.type === 'box_plot' && (
                      <Box
                        plotData={plotData.testData}
                      />
                    )
                  }
                  {
                    disp.type === 'scatter_plot' && (
                      <Scatter
                        plotData={plotData.testData}
                      />
                    )
                  }
                  {
                    disp.type === 'table' && (
                      <Table
                        computationOutput={computationOutput}
                        plotData={plotData}
                        tables={disp.tables ? disp.tables : null}
                        title={`${consortium.name}_${run.pipelineSnapshot.name}`}
                      />
                    )
                  }
                  {
                    disp.type === 'images' && (
                      <Images
                        plotData={plotData}
                        title={`${consortium.name}_${run.pipelineSnapshot.name}`}
                      />
                    )
                  }
                </Tab>
              );
            })
          }
        </Tabs>
        {
          run && run.error && (
            <Well style={{ color: 'red' }}>
              {JSON.stringify(run.error.message, null, 2)}
            </Well>
          )
        }
      </div>
    );
  }
}

Result.propTypes = {
  consortia: PropTypes.array.isRequired,
  getLocalRun: PropTypes.func.isRequired,
  params: PropTypes.object.isRequired,
};

const mapStateToProps = ({ auth }) => {
  return { auth };
};

export default connect(mapStateToProps, { getLocalRun })(Result);
